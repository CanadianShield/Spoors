# 🐾 S01E05 - WMI logging

In the PowerShell script there was the following cmdlet:
```powershell
Invoke-WmiMethod -Class StdRegProv -Name SetStringValue -ArgumentList (2147483649,"SOFTWARE","Yes","CanBeDeleted")
```
What do we see from this in the local system?

## ❓ What is there by default?

Nothing.

We can't rely on the WmiPrvSE start and stop time as its lifecycle is managed automatically by the WMI service and is likely already running before the method called by this script gets to run.

## ❓ How to audit WMI activity? 

Like other components of the operating system, we can track access (read and write) to WMI objects using a combination of Advanced Audit Policy and SACL. The advanced audit policy we would need is the sub category `Other Object Access Events`:

![WMI audit policy](/Images/S01E05-01.png)

For additional info about `auditpol.exe`, see the episode [S01E03](S01E03.md).

Then the SACL needs to be set on the objects. These objects can be found in the WMI Control console `wmimgmt.msc`. 

![WMI SACL](/Images/S01E05-02.png)

The issue in a real case is that you can't always determine in advance what what is going to be leveraged for malicious. And setting a very large scope of SACL might lead to a flood of events. Just for the sake of our scenario, if the audit was enabled for read access on the `root\cimv2` namespace, we would have seen the following `4662` events in the `Security` event log:

![4662](/Images/S01E05-03.png)

 We would actually see way more than that if we enabled the audit for read access. And the following for method execution:

![4662](/Images/S01E05-04.png)

Note that we see the `StdRegProv` provider was called, we see the method called `SetStringValue`, but we don't see the parameters of the function. After all that effort, we know that the method was called, but we don't know what it did.

## 🧐 What about the builtin WMI activity event log?

The `Microsoft-Windows-WMI-Activity/Operational` event log will not mention successful calls. It can however show you the exceptions which were generated if any. But there were none in our scenario.

The `Microsoft-Windows-WMI-Activity/Trace` which is disabled by default will show us thing. At a very verbose price, but it will tell us a method of a provider was called:

![12](/Images/S01E05-05.png)

And some metadata about the call:

![22](/Images/S01E05-06.png)

But here we won't see the details passed in argument to the method. Not useful in our scenario. 
It can be useful in other circumstances when we need to know what happens at the WMI level. For example, if you run the following command:
```
Get-WmiObject -NameSpace root/cimv2-Query "SELECT * FROM Win32_Process"
```
The following event will show the WQL filter:

![11](/Images/S01E05-07.png)

The event log `Microsoft-Windows-WMI-Activity/Debug` doesn't show anything usable (it seems).

## 👨‍💻 WMIMon

The tool [WMIMon](https://github.com/luctalpe/WMIMON) is awesome tool for WMI troubleshooting. But...
1. it is not running when the bad things happened (or you are very lucky to do troubleshooting at the same time) 
2. it still doesn't show the arguments passed to the method

![WMIMon](/Images/S01E05-08.png)

## 🔬 What do we see in Microsoft Defender for Endpoint?

The WMI activity generated by our macro was detected but only because we used it in monitored PowerShell cmdlet:

![MDE 1](/Images/S01E05-09.png)

And we still don't see all the parameters:

![MDE 2](/Images/S01E05-10.png)

## 📝 Summary

|Event ID|Event Log|Enabled by default|Builtin feature|Notes|
|--|--|--|--|--|
|`4662`|`Security`|No|Yes|Requires SACL and can be very verbose|
|`11`,`12`,`22`|`Microsoft-Windows-WMI-Activity/Trace`|No|Yes|Very verbose|

❎ Note that we don't mention anything about WMI persistence here. It will be the topic of another episode. As a spoiler, you can use Sysmon and its events `19`, `20` and `21` to detect WMI persistence attempts.