# 🐾 S01E07 - Track outbound network connections 

Our *fake* call to a C2 server is sits in the obfuscated PowerShell code launched by the Excel macro:

```powershell
Invoke-WebRequest -Uri "http://perdu.com"
```

This outbound connection offers three opportunities to be seen.
1. It is using a FQDN, so the name resolution might tell us a part of the story (transaction and/or the resolver's cache)
2. The network connection has to go through the different layers of the OS can be seen by our local Windows firewall and additional tools (such as EDR or some local tools such as `Sysmon`). And if the device is connected within our network, the different network equipment on the way to the Internet.
3. As an HTTP call, if there were some HTTP proxy configuration, we could also see that call in these logs.

We are going to focus on what is left on the actual machine where the connection took place, so essentially the point 1 and a part of the point 2.

## 🔥 Windows Firewall

There are two ways to log things with the Windows Firewall:
1. Text logging with the pfirewall.log file
2. The event based logging through the `Filtering Platform Connection` advanced audit policy subcategory. 


## 🕵️‍♀️ DNS lookups

There is a very verbose logs (understand, you might be able to use it only for temporary troubleshooting - not to mention that its default size is 1Mb) in Windows called `Microsoft-Windows-DNS-Client/Operational`. One DNS lookup will generate a bunch of things there that will tell you if the record what found in the cache, what interface the query used, what DNS server answered, some performance data and even the PID of the caller (although that last one seem to be specific to Windows 11). 

Here is an example of xPath filter you can use to show only the things related to `perdu.com`:

```
 * [ EventData[ Data[@Name='QueryName'] and (Data='perdu.com')] ] 
```
Of course, in a hunting situation, you don't know in advance what name to look for. And you might not even have a name if the call is made with an IP address anyways. But for the sake of it, let's have a look at the events a call in ou case would generate:

![DNS events](Images/S01E07-01.png)

The first `3006` entry gives us the request:
```
DNS query is called for the name perdu.com, type 1, query options 1073766400, Server List , isNetwork query 0, network index 0, interface index 0, is asynchronous query 0
```
Then we have a bunch of metadata from the call (interfaces, DNS servers...) and at some point we got an answer in the event `3020`:
```
Query response for name perdu.com, type 1, interface index 0 and network index 0 returned 0 with results 208.97.177.124;
```
If you wish to know all possible events generated by this source, you can run the following cmdlets:

```powershell
(Get-WinEvent -ListProvider "Microsoft-Windows-DNS-Client").Events | `
    Select-Object @{Name='Id';Expression={$_.Id -band 0xffffff}}, Description, @{Name='Parameters';Expression={($_.Template).template.data}} | `
        Out-GridView -Title "DNS Event IDs"
```

Here is an example of the output taken on a Windows 11 machine:

![list all DNS events](Images/S01E07-02.png)

The cache has also some value since you will be able to pin point at the second when a request was made by looking at the TTL (and assuming that you know what is the records default TTL and that the record is still in cache), you could do the old school way `ipconfig /displaydns` or get modern with `Get-DnsClientCache`. In our case, our records TTL is 4 hours. We know that from a quick nslookup:

```
HEADER:
    opcode = QUERY, id = 2, rcode = NOERROR
    header flags:  response, want recursion, recursion avail.
    questions = 1,  answers = 1,  authority records = 0,  additional = 0

QUESTIONS:
    perdu.com, type = A, class = IN
ANSWERS:
->  perdu.com
    internet address = 208.97.177.124
    ttl = 14400 (4 hours)
```

So to know when a resolution was made, we could use:

```powershell
$perdu = Get-DnsClientCache -Entry "perdu.com"
(Get-Date).AddSeconds(-(14400 - $perdu.TimeToLive))
```
This will return the timestamp at which the call was made which can then be used to narrow down the process creation event search or give us a starting point to look at PowerShell logs or even network logs.


## 🕵️‍♀️ MDE, DNS lookup and outbound connections

It seems that `MsSense.exe` substitutes itself to the classic resolver when Microsoft Defender for Endpoint is in the game. We'll cover that in another season but don't be scared if you see your request are coming from this process. It also gets us the following in the device timeline:

![lMDE](Images/S01E07-03.png)

It even associated the call with [T1043](https://attack.mitre.org/techniques/T1043/) (which is actually a deprecated technique) and a Command and Control tactic. 

## ⛑️ Sysmon here to help again

Sysmon will help us by giving us more granularity of logging. Of course in a case of an investigation, if it wasn't on at the time of the suspecious action, it won't help. But it it was on, and maybe configure with the options we already mentionned in previous episodes (such as the configuration suggested by [SwiftOnSecurity](https://github.com/SwiftOnSecurity/sysmon-config/blob/master/sysmonconfig-export.xml)) we will see the following events for DNS resolutions and outbound connections:

![sysmon 22](Images/S01E07-04.png)

Followed by:

![sysmon 3](Images/S01E07-05.png)

💡 Note that in the even `3` the DNS hostname is not what what the caller sent but what the [`GetNameInfo`](https://docs.microsoft.com/en-us/windows/win32/api/ws2tcpip/nf-ws2tcpip-getnameinfo) API returns. 


## 📝 Summary

|Event ID|Event Log|Enabled by default|Builtin feature|Notes|
|--|--|--|--|--|
|`3006`,`3020`|`Microsoft-Windows-DNS-Client`|No|Yes|Very verbose|
|`3`,`22`|`Microsoft-Windows-Sysmon/Operational`|No|No|Requires custom configuration file|